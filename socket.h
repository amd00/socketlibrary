
#ifndef _SOCKET_H_
#define _SOCKET_H_

#include <sys/socket.h>
#include <sys/poll.h>

////////////////////////////////////////////////////////////////////////////////////

//! \brief Абстрактный класс, реализующий взаимодействие через присоединённый сокет

/*! Реализованы методы подключения, отправки, и приёма данных через присоединённый сокет.
	\sa TcpSocket UnixSocket
*/

class Socket
{
	/*! \sa ServerSocket
	*/
	friend class ServerSocket;
private:
	//! Файловый дескриптор.
	/*! Дескриптор, используемый для сетевого взаимодействия.
	*/
	int sock;										// Файловый дескриптор
	//! Структура \e pollfd.
	/*! Указатель на \e fds передаётся в функцию \e poll для получения информации
		о событиях на файловом дескрипторе.
	*/
	pollfd fds;									// Массив структур "pollfd"

	int last_error;

	//! Состояние сокета.
	/*! Сохраняет состояние сокета (\b true - подключён, \b false - не подключён).
	\sa Connect() Connect(int, int, sockaddr*, socklen_t)
	*/
	bool connected;									// Состояние сокета
	//! Посылка блока данных.
	/*! Выполняет посылку данных через сокет, если на файловом дескрипторе \e sock
		установлен флаг \b O_NONBLOCK.
		\param data - данные для посылки.
		\param data_size - размер отсалаемых данных в байтах.
		\param timeout - таймаут в милисекундах.

		\return Возвращает количество отправленных байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
		\sa Connect() Disconnect()
	*/
	int SyncSend(const void *data, size_t data_size, int timeout = -1);
	//! Посылка блока данных.
	/*! Выполняет посылку данных через сокет, если на файловом дескрипторе \e sock
		установлен флаг \b O_ASYNC.
		\param data - данные для посылки.
		\param data_size - размер отсалаемых данных в байтах.
		\param timeout - таймаут в милисекундах.

		\return Возвращает количество отправленных байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
		\sa AsyncSend(), SyncRecv(), AsyncRecv(), Send(), Recv()
	 */
	int AsyncSend(const void *data, size_t data_size, int timeout = -1);
	//! Приём блока данных.
	/*! Выполняет приём данных из сокета, если на файловом дескрипторе \e sock
		установлен флаг \b O_NONBLOCK.
		\param data - буфер для приёма нанных.
		\param data_size - размер принимаемых данных в байтах.
		\param timeout - таймаут в милисекундах.
	
		\return Возвращает количество принятых байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
	
		\sa SyncSend(), SyncRecv(), AsyncRecv(), Send(), Recv()
	*/
	int SyncRecv(void *data, size_t data_size, int timeout = -1);
	//! Приём блока данных.
	/*! Выполняет приём данных из сокета, если на файловом дескрипторе \e sock
		установлен флаг \b O_ASYNC.
		\param data - буфер для приёма нанных.
		\param data_size - размер принимаемых данных в байтах.
		\param timeout - таймаут в милисекундах.

		\return Возвращает количество принятых байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
	
		\sa SyncSend(), AsyncSend(), AsyncRecv(), Send(), Recv()
	 */
	int AsyncRecv(void *data, size_t data_size, int timeout = -1);
protected:
	//! Метод для подключения к серверу
	/*! Выполнят подключение к серверу с помощью функции \e connect.
		\param domain - семейство сокетов (PF_INET, PF_UNIX)
		\param type - тип сокета (SOCK_STREAM)
		\param addr - указатель на структуру \b sockaddr
		\param sl - размер \e *addr
	
		\return \b true - в случае успешного подключения, \b false - в случае неудачи.
		
		\sa Send(), Recv()
	 */
		bool Connect(int domain, int type, sockaddr *addr, socklen_t sl);	// Метод, осуществляющий соединение
	//! Конструктор.
	/*! Конструктор, создающий объект \e Socket по файловому дескриптору.
		\param fd - файловый дескриптор.
	 */
		Socket(int fd);									// Конструктор
public:
	//! Конструктор
	Socket();										// Конструктор
	//! Деструктор
	virtual ~Socket();								// Деструктор
	//! Выполняет подключение.
	/*! Пытается подключиться к серверу.
		
		\return Возвращает \b true - в случае успешного подключения, \b false - в случае неудачи.
	
		\sa Connect(int, int, sockaddr*, socklen_t)
	*/
	virtual bool Connect() = 0;
	//! Посылка блока данных.
	/*! Выполняет посылку данных через сокет. Для посылки используются методы
		\e SyncSend и \e AsyncSend, в зависимости от свойств сокета.
		
		\param data - данные для посылки.
		\param data_size - размер отсалаемых данных в байтах.
		\param timeout - таймаут в милисекундах.

		\return Возвращает количество отправленных байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
		
		\sa Recv()
	 */
	int Send(const void *data, size_t data_size, int timeout = -1);// Метод, осуществляющий посылку данных
	//! Приём блока данных.
	/*! Выполняет приём данных из сокета. Для посылки используются методы
		\e SyncRecv и \e AsyncRecv, в зависимости от свойств сокета.
		
		\param data - буфер для приёма нанных.
		\param data_size - размер принимаемых данных в байтах.
		\param timeout - таймаут в милисекундах.
		
		\return Возвращает количество принятых байт, 0 - если произошёл разрыв
			соединения  или -1 в случае ошибки.
	
		\sa Send()
	*/
	int Recv(void *data, size_t data_size, int timeout = -1);		// Метод, осуществляющий приём данных
	//! Ожидание данных
	/*! Метод блокирует управление, в сокет не придут данные или не истечёт таймаут.
		Для ожидания данных используется функция \e poll.
	
		\param timeout - таймаут в милисекундах.
	
	*/
	void WaitData(int timeout = -1);
	//! Закрывает соединение.
	/*! Закрывает соединение, созданное методом \e Connect().
	*/
	void Disconnect();								// Разрыв соединения
	//! Возвращает удалённый адрес.
	/*! Возвлащает адрес сокета на другом конце соединения.
	*/
	virtual const char *Address() = 0;				// Удалённый адрес (путь к файлу)
	//! Возвращает состояние.
	/*! Возвращает состояние сокета.
		
		\return \b true - если сокет подключён, \b false - если не подключён.
	
		\sa Connect()
	*/
	bool Connected() const;							// Метод, возвращающий состояние сокета
	//! Файловый дескриптор.
	/*! Возвращает файловый дескриптор сокета.
		\return Файловый дескриптор.
	*/
	int Fd() const;									// Метод, возвращающий файловый дескриптор
};

////////////////////////////////////////////////////////////////////////////////////

#endif

